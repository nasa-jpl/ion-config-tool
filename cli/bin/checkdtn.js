#!/usr/bin/env node
// THIS FILE IS AUTOMATICALLY GENERATED DURING THE BUILD PROCESS
// SEE THE MAKE SCRIPT FOR WHICH SOURCE FILES ARE USED TO BUILD IT
//
//    checkdtn.js 
//
//  check the validity of syntax and content of a dtnmodel
//
//  usage:  checkdtn.js -m [netmodelfile]
//
//  inputs: net_model.json  (or alternative name)
//
//  outputs: progress messages,
//           error messages
//
//  author: Rick Borgen
//

const mm = require('minimist');
const fs = require('fs');

var debugFlag = false;

console.log("DTN Network Model Validation");

var argv = mm(process.argv.slice(2));
var long = argv.l;
if (long)
  console.log("long mode");
var fname = argv.m;
console.log("Model file: " + fname);  
var json;
try {
  json = JSON.parse(fs.readFileSync(fname,'utf8'));
} catch (err) {
  error("Cannot process file: " + fname);
  console.log("" + err);
  process.exit();
}
console.log("JSON parsing successful.");
console.log("Object: " + JSON.stringify(json) );
console.log("---");
var netName  = {};
var netHosts = {};
var netNodes = {};
var netHops  = {};
var netAddrs = {};

////////////////////////
// In netloader.js
[netName,netHosts,netNodes,netHops,netAddrs] = extractModel(json);
////////////////////////
console.log("Ingestion complete.");

console.log("---");
console.log("Ingestion summary:");
console.log("netHosts: " + Object.keys(netHosts));
console.log("netNodes: " + Object.keys(netNodes));
console.log("netHops: "  + Object.keys(netHops));
console.log("netAddrs: " + netAddrs);
console.log("---");
console.log("Checking user net model.");

///////////////////////
// In checknet.js
var errors = checkNetModel(netHosts,netNodes,netHops);
///////////////////////

if (errors.length) {
  console.log("Validation errors.");   
  for (let i=0; i<errors.length; i++) {
    error(errors[i]);
  }
} else {
  console.log("Validation successful.");   
}
console.log("Done.");


// Automatically extracted from source file ../../editor/src/NetModelLoader.jsx
function extractModel(modelObj) {
    // extract the Net config JSON structure &
    // flatten the data structures for efficient access

    // make short names for state objects
    var net = {};
    var hosts = {};
    var nodes = {};
    var hops = {};
    var netaddrs = [];

    //console.log("=== Ingesting user net model.  net: " + JSON.stringify(net));
    //console.log("net WAS: " + JSON.stringify(net));
    if(modelObj.hasOwnProperty("netModelName"))
      net.name = modelObj["netModelName"];
    else {
       setError("The json file is not a Net Model.");
       return false;
    }
    if(modelObj.hasOwnProperty("netModelDesc"))
      net.desc = modelObj["netModelDesc"];

    console.log("=== Ingesting netHosts.");
    var hostList = [];
    if(modelObj.hasOwnProperty("netHosts")) 
      hostList = modelObj.netHosts;
    for (var hostKey in hostList) {
      var hostObj = hostList[hostKey];
      var desc = '';
      if(hostObj.hasOwnProperty("hostDesc"))
        desc = hostObj["hostDesc"];
      let addrs = [];
      if(hostObj.hasOwnProperty("ipAddrs"))
        addrs = hostObj["ipAddrs"];

      // build the hosts state object
      hosts[hostKey] = { 
        "id" : hostKey, 
        "hostDesc" : desc,
        "ipAddrs" : addrs
      };
      // add the ip addrs to master list
      for (var i=0; i<addrs.length; i++)
        netaddrs.push(addrs[i]);

    };
    console.log("net IS:  " + JSON.stringify(net));
    console.log("=== Ingesting netNodes.");
    var nodeList = [];
    if(modelObj.hasOwnProperty("netNodes"))  // optional for now.
      nodeList = modelObj.netNodes;
    for (var nodeKey in nodeList) {
      var nodeObj = nodeList[nodeKey];
      desc = '';
      if(nodeObj.hasOwnProperty("nodeDesc"))
        desc =nodeObj["nodeDesc"];
      var host = '';
      if(nodeObj.hasOwnProperty("nodeHost"))
        host =nodeObj["nodeHost"];
      var type = '';
      if(nodeObj.hasOwnProperty("nodeType"))
        type =nodeObj["nodeType"];
      var ep = '';
      if(nodeObj.hasOwnProperty("endpointID"))
         ep = nodeObj["endpointID"];
      var servs= [];
      if(nodeObj.hasOwnProperty("services"))
        servs = nodeObj["services"];
      // build the nodes state object
      nodes[nodeKey] = { 
        "id" : nodeKey, 
        "nodeDesc" : desc, 
        "nodeHost" : host,
        "nodeType" : type,
        "endpointID" : ep,
        "services" : servs
      };
    }
    console.log("=== Ingesting netHops.");
    var hopList = [];
    if(modelObj.hasOwnProperty("netHops"))  // optional for now.
      hopList = modelObj.netHops;
    for (var hopKey in hopList) {
      var hopObj = hopList[hopKey];
      desc = '';
      if(hopObj.hasOwnProperty("hopDesc"))
        desc = hopObj["hopDesc"];
      var fromnode = '';
      if(hopObj.hasOwnProperty("fromNode"))
        fromnode = hopObj["fromNode"];
      var fromip = '';
      if(hopObj.hasOwnProperty("fromIP"))
        fromip = hopObj["fromIP"];
      var tonode = '';
      if(hopObj.hasOwnProperty("toNode"))
        tonode = hopObj["toNode"];
      var toip = '';
      if(hopObj.hasOwnProperty("toIP"))
        toip = hopObj["toIP"];
      var bp = '';
      if(hopObj.hasOwnProperty("bpLayer"))
        bp = hopObj["bpLayer"];
      var ltp = '';
      if(hopObj.hasOwnProperty("ltpLayer"))
        ltp = hopObj["ltpLayer"];
      var port = '';
      if(hopObj.hasOwnProperty("portNum"))
        port = hopObj["portNum"];
      var rate = 0;
      if(hopObj.hasOwnProperty("maxRate"))
        rate = hopObj["maxRate"];
      var sym = "no";
      var flag = false;
      if(hopObj.hasOwnProperty("symmetric"))
        flag = hopObj["symmetric"];
      var sym = true;
      if (!flag || flag === "false" || flag === "no")
        sym = false;
      // build the nodes state object
      hops[hopKey] = { 
        "id" : hopKey, 
        "hopName": hopKey,
        "hopDesc": desc,
        "fromNode": fromnode,
        "fromIP": fromip,
        "toNode": tonode,
        "toIP": toip,
        "bpLayer": bp,
        "ltpLayer": ltp,
        "portNum": port,
        "maxRate": rate,
        "symmetric": sym
      };
    };
    return [net,hosts,nodes,hops,netaddrs];
  };
// Automatically extracted from source file ../../editor/src/NetModel.jsx
function checkNetModel(netHosts,netNodes,netHops) {
  // make list of errors in net model
    var errors = [];   // list of messages (strings)

    // do some sanity checking on net model
    if (!netHosts)  // no host object?
      errors.push("The Net Model has no Host list.")
    if (!Object.keys(netHosts).length)   // no hosts?
      errors.push("The Net Model has no Hosts.");
    if (!netNodes)  // no node object?
      errors.push("The Net Model has no Node list.");
    if (!Object.keys(netNodes).length)   // no nodes?
      errors.push("The Net Model has no Nodes.");
    for (var nodeKey in netNodes) {
      var netNode = netNodes[nodeKey];
      var hostKey = netNode.nodeHost;
      debug("**** hostKey =" + hostKey);
      var hostObj = netHosts[hostKey];
      if (!hostObj)
        errors.push("Invalid hostKey for node " + nodeKey + ".");
    }
    // sanity checking on each hop
    for (var hopKey in netHops) {
      var netHop = netHops[hopKey];
      var fromNode = netNodes[netHop.fromNode];
      if (!fromNode) 
        errors.push("Invalid From Node Name for Net Hop " + hopKey + ".");
      var toNode = netNodes[netHop.toNode];
      if (!toNode) 
        errors.push("Invalid To Node Name for Net Hop " + hopKey + ".");

      var toIP = netHop.toIP;
      var fromIP = netHop.fromIP;

      for (var netHostKey in netHosts) {
        var netHost = netHosts[netHostKey];
        if (fromNode) {
          if (netHostKey === fromNode.nodeHost) {
            if (!netHost.ipAddrs.includes(fromIP))
              errors.push("Invalid 'From IP Addr': " + fromIP + " for Net Hop " + hopKey + ".");
          }
        }
        if (toNode) {
          if (netHostKey === toNode.nodeHost) {
            if (!netHost.ipAddrs.includes(toIP))
              errors.push("Invalid 'To IP Addr': " + toIP + " for Net Hop " + hopKey + ".");
          }
        }
      }

      if (!netHop.bpLayer)
        errors.push("Missing BP Layer Protocol CLA for Net Hop " + hopKey + ".");
      if (netHop.bpLayer && !isStandardProtocol(netHop.bpLayer)) 
        errors.push("Unrecognized BP Layer Protocol CLA for Net Hop: "+ hopKey +". Should be one of: tcp, stcp, udp, dccp or ltp.");
    }
    return errors;
  }
// Automatically extracted from source file ../../editor/src/App.jsx
function isGoodName(name) {
  // check if a new name is valid
  debug("isGoodName ?? " + name);
    if (name === '')
      return false;
    if (name.indexOf(' ') >= 0)
      return false;
    return true;
  }
// Automatically extracted from source file ../../editor/src/App.jsx
function isStandardProtocol(protocol) {
  //check if protocol has a standard ION CLI
    if (protocol === "tcp"  ||
        protocol === "stcp" ||
        protocol === "udp"  ||
        protocol === "dccp" ||
        protocol === "bssp" ||
        protocol === "ltp") 
      return true;
    else
      return false;
  }
// Automatically extracted from source file ../../editor/src/App.jsx
function getUniqId() {
  // generate next uniq id...used by all types
     let nextId = uniqId + 1;
     uniqId = nextId;
     return nextId;
  }
// Automatically extracted from source file ../../editor/src/NetModel.jsx
function addCommandKey(configs,configName,cmdKey) {
  // add commmand to a configuration, unless its null
    if (cmdKey == null) {
      debug("addCommandKey discarded for configFile: " + configName);
      return;
    }
    configs[configName].cmdKeys.push(cmdKey);
  }
// Automatically extracted from source file ../../editor/src/NetModel.jsx
function makeIonCommand(commands,clones,groupKey,configKey,configType,cmdName,values) {
  // build an ion command object
    // NOTE: the default behavior is to use the latest version of each command type
    // By convention, the latest command is simply the configType + cmdName
    // Prior command versions have _vxx suffix showing the last version supported
    let cmdTypeKey = configType + "_" + cmdName;
    let uniqid = getUniqId();
    let cmdKey = "cmd_" + uniqid;
    let cmdType = cmdTypes[cmdTypeKey];
    debug("makeIonCommand ... configType: " + configType + 
                " groupKey: " + groupKey + " cmdName: " + cmdName +
                " cmdKey: " + cmdKey + " values: " + values);
    if (cmdType === null)
      return null;
    // check for duplicate command & exit if dup exists
    for (var cKey in commands) {
      let cmd = commands[cKey];
      if (cmd.configKey === configKey) {     // matching config file?
        if (cmd.typeKey === cmdTypeKey) {    // matching command type
          var match = true;
          for (let i = 0; i < cmd.values.length; i++) {
            if (cmd.values[i] !== values[i])
              match = false;
          }
          if (match) {
            debug("$$$$$$$ makeIonCommand duplicate command: " + JSON.stringify(cmd));
            return null;
          }
        } // end cmdTypeKey check
      }   // end configKey check
    }     // end commands loop
    let tranTime = getNow();
    commands[cmdKey] = {
      "id" : cmdKey,
      "configKey" : configKey,
      "typeKey" : cmdTypeKey,
      "typeName" : cmdType.name,
      "order" : cmdType.order,
      "lastUpdate" : tranTime,
      "values" : values
    };
    if (cmdType.isCloned) {
      var cloneVal = makeCloneVal(groupKey,commands[cmdKey]);
      var cvKey = cloneVal.id;
      clones[cvKey] = cloneVal;
    } 
    return cmdKey;
  };
// Utility functions used by all CLI apps that are not part
// of the automatic extraction

// Special wrapper function for console.log debug messages
function debug_log(msg) {
  if (DEBUG_MODE)
     console.log(msg);
}

function warn(s) {
  console.log("Warning: "  + s);
}
function error(s) {
  console.log("Error: "  + s);
}
function setError(s) {
  console.log("Error: "  + s);
}
function debug(s) {
  if (debugFlag) 
    console.log("$$$ " + s);
}

// get now date-time in standard format
function getNow() {
  const now = new Date();
  var goodNow = df.formatISO(now); 
  goodNow = goodNow.substring(0,16);
  return goodNow;
};