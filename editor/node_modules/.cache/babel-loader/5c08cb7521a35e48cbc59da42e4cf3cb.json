{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginUtils\n */\n'use strict';\n\nvar EventConstants = require('./EventConstants');\n\nvar ReactErrorUtils = require('./ReactErrorUtils');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar warning = require('fbjs/lib/warning');\n/**\n * Injected dependencies:\n */\n\n/**\n * - `Mount`: [required] Module that can convert between React dom IDs and\n *   actual node references.\n */\n\n\nvar injection = {\n  Mount: null,\n  injectMount: function injectMount(InjectedMount) {\n    injection.Mount = InjectedMount;\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;\n    }\n  }\n};\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nfunction isEndish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;\n}\n\nfunction isStartish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;\n}\n\nvar validateEventDispatches;\n\nif (process.env.NODE_ENV !== 'production') {\n  validateEventDispatches = function validateEventDispatches(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchIDs = event._dispatchIDs;\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var idsIsArr = Array.isArray(dispatchIDs);\n    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;\n  };\n}\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {string} domID DOM id to pass to the callback.\n */\n\n\nfunction executeDispatch(event, simulated, listener, domID) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = injection.Mount.getNode(domID);\n\n  if (simulated) {\n    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);\n  } else {\n    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);\n  }\n\n  event.currentTarget = null;\n}\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\n\n\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      } // Listeners and IDs are two parallel arrays that are always in sync.\n\n\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);\n  }\n\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n}\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\n\n\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      } // Listeners and IDs are two parallel arrays that are always in sync.\n\n\n      if (dispatchListeners[i](event, dispatchIDs[i])) {\n        return dispatchIDs[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchIDs)) {\n      return dispatchIDs;\n    }\n  }\n\n  return null;\n}\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchIDs = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\nfunction executeDirectDispatch(event) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n\n  var dispatchListener = event._dispatchListeners;\n  var dispatchID = event._dispatchIDs;\n  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;\n  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n  return res;\n}\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n/**\n * General utilities that are useful in creating custom Event Plugins.\n */\n\n\nvar EventPluginUtils = {\n  isEndish: isEndish,\n  isMoveish: isMoveish,\n  isStartish: isStartish,\n  executeDirectDispatch: executeDirectDispatch,\n  executeDispatchesInOrder: executeDispatchesInOrder,\n  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n  hasDispatches: hasDispatches,\n  getNode: function getNode(id) {\n    return injection.Mount.getNode(id);\n  },\n  getID: function getID(node) {\n    return injection.Mount.getID(node);\n  },\n  injection: injection\n};\nmodule.exports = EventPluginUtils;","map":{"version":3,"names":["EventConstants","require","ReactErrorUtils","invariant","warning","injection","Mount","injectMount","InjectedMount","process","env","NODE_ENV","getNode","getID","undefined","topLevelTypes","isEndish","topLevelType","topMouseUp","topTouchEnd","topTouchCancel","isMoveish","topMouseMove","topTouchMove","isStartish","topMouseDown","topTouchStart","validateEventDispatches","event","dispatchListeners","_dispatchListeners","dispatchIDs","_dispatchIDs","listenersIsArr","Array","isArray","idsIsArr","IDsLen","length","listenersLen","executeDispatch","simulated","listener","domID","type","currentTarget","invokeGuardedCallbackWithCatch","invokeGuardedCallback","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchID","res","hasDispatches","EventPluginUtils","id","node","module","exports"],"sources":["/Users/rlborgen/git/ionconfig/editor/node_modules/react-popout/node_modules/react/lib/EventPluginUtils.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginUtils\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar ReactErrorUtils = require('./ReactErrorUtils');\n\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\n/**\n * Injected dependencies:\n */\n\n/**\n * - `Mount`: [required] Module that can convert between React dom IDs and\n *   actual node references.\n */\nvar injection = {\n  Mount: null,\n  injectMount: function (InjectedMount) {\n    injection.Mount = InjectedMount;\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;\n    }\n  }\n};\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nfunction isEndish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;\n}\n\nvar validateEventDispatches;\nif (process.env.NODE_ENV !== 'production') {\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchIDs = event._dispatchIDs;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var idsIsArr = Array.isArray(dispatchIDs);\n    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {string} domID DOM id to pass to the callback.\n */\nfunction executeDispatch(event, simulated, listener, domID) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = injection.Mount.getNode(domID);\n  if (simulated) {\n    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);\n  } else {\n    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);\n  }\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);\n  }\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchIDs[i])) {\n        return dispatchIDs[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchIDs)) {\n      return dispatchIDs;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchIDs = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchID = event._dispatchIDs;\n  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;\n  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * General utilities that are useful in creating custom Event Plugins.\n */\nvar EventPluginUtils = {\n  isEndish: isEndish,\n  isMoveish: isMoveish,\n  isStartish: isStartish,\n\n  executeDirectDispatch: executeDirectDispatch,\n  executeDispatchesInOrder: executeDispatchesInOrder,\n  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n  hasDispatches: hasDispatches,\n\n  getNode: function (id) {\n    return injection.Mount.getNode(id);\n  },\n  getID: function (node) {\n    return injection.Mount.getID(node);\n  },\n\n  injection: injection\n};\n\nmodule.exports = EventPluginUtils;"],"mappings":"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"},"metadata":{},"sourceType":"script"}