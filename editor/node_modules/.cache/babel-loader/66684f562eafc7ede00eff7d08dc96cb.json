{"ast":null,"code":"/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n'use strict';\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\n\nvar ReactElement = require('./ReactElement');\n\nvar ReactInstanceMap = require('./ReactInstanceMap');\n\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar warning = require('fbjs/lib/warning');\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;\n    }\n\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;\n  }\n\n  return internalInstance;\n}\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\n\n\nvar ReactUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function isMounted(publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function enqueueCallback(publicInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance); // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    } // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n\n\n    enqueueUpdate(internalInstance);\n  },\n  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function enqueueSetState(publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);\n  },\n  enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined; // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    var props = assign({}, element.props, partialProps);\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);\n  },\n  enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined; // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n    enqueueUpdate(topLevelWrapper);\n  },\n  enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n};\nmodule.exports = ReactUpdateQueue;","map":{"version":3,"names":["ReactCurrentOwner","require","ReactElement","ReactInstanceMap","ReactUpdates","assign","invariant","warning","enqueueUpdate","internalInstance","getInternalInstanceReadyForUpdate","publicInstance","callerName","get","process","env","NODE_ENV","constructor","displayName","undefined","current","ReactUpdateQueue","isMounted","owner","_warnedAboutRefsInRender","getName","_renderedComponent","enqueueCallback","callback","_pendingCallbacks","push","enqueueCallbackInternal","enqueueForceUpdate","_pendingForceUpdate","enqueueReplaceState","completeState","_pendingStateQueue","_pendingReplaceState","enqueueSetState","partialState","queue","enqueueSetProps","partialProps","enqueueSetPropsInternal","topLevelWrapper","_topLevelWrapper","wrapElement","_pendingElement","_currentElement","element","props","cloneAndReplaceProps","enqueueReplaceProps","enqueueReplacePropsInternal","enqueueElementInternal","newElement","module","exports"],"sources":["/Users/rlborgen/git/ionconfig/editor/node_modules/react-popout/node_modules/react/lib/ReactUpdateQueue.js"],"sourcesContent":["/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactElement = require('./ReactElement');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;\n    }\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);\n  },\n\n  enqueueSetPropsInternal: function (internalInstance, partialProps) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    var props = assign({}, element.props, partialProps);\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);\n  },\n\n  enqueueReplacePropsInternal: function (internalInstance, props) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  enqueueElementInternal: function (internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;"],"mappings":"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"},"metadata":{},"sourceType":"script"}