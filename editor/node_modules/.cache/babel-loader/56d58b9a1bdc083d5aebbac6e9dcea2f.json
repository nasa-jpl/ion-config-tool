{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n'use strict';\n\nvar CallbackQueue = require('./CallbackQueue');\n\nvar PooledClass = require('./PooledClass');\n\nvar ReactPerf = require('./ReactPerf');\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar Transaction = require('./Transaction');\n\nvar assign = require('./Object.assign');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function initialize() {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function close() {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\nvar UPDATE_QUEUEING = {\n  initialize: function initialize() {\n    this.callbackQueue.reset();\n  },\n  close: function close() {\n    this.callbackQueue.notifyAll();\n  }\n};\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* forceHTML */\n  false);\n}\n\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function getTransactionWrappers() {\n    return TRANSACTION_WRAPPERS;\n  },\n  destructor: function destructor() {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n  perform: function perform(method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\n\n\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined; // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i]; // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function flushBatchedUpdates() {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n\nflushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\n\nfunction enqueueUpdate(component) {\n  ensureInjected(); // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\n\n\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;\n    batchingStrategy = _batchingStrategy;\n  }\n};\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\nmodule.exports = ReactUpdates;","map":{"version":3,"names":["CallbackQueue","require","PooledClass","ReactPerf","ReactReconciler","Transaction","assign","invariant","dirtyComponents","asapCallbackQueue","getPooled","asapEnqueued","batchingStrategy","ensureInjected","ReactUpdates","ReactReconcileTransaction","process","env","NODE_ENV","undefined","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","callbackQueue","reset","notifyAll","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","prototype","Mixin","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","c","d","e","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","sort","i","component","callbacks","_pendingCallbacks","performUpdateIfNecessary","j","enqueue","getPublicInstance","queue","measure","enqueueUpdate","isBatchingUpdates","push","asap","context","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","injection","module","exports"],"sources":["/Users/rlborgen/git/ionconfig/editor/node_modules/react-popout/node_modules/react/lib/ReactUpdates.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactPerf = require('./ReactPerf');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);\n}\n\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;"],"mappings":"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"},"metadata":{},"sourceType":"script"}