{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n'use strict';\n\nvar DOMChildrenOperations = require('./DOMChildrenOperations');\n\nvar DOMPropertyOperations = require('./DOMPropertyOperations');\n\nvar ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');\n\nvar ReactMount = require('./ReactMount');\n\nvar assign = require('./Object.assign');\n\nvar escapeTextContentForBrowser = require('./escapeTextContentForBrowser');\n\nvar setTextContent = require('./setTextContent');\n\nvar validateDOMNesting = require('./validateDOMNesting');\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\n\n\nvar ReactDOMTextComponent = function ReactDOMTextComponent(props) {// This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function construct(text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text; // Properties\n\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function mountComponent(rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    this._rootNodeID = rootID;\n\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID); // Populate node cache\n\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function receiveComponent(nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n  unmountComponent: function unmountComponent() {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n});\nmodule.exports = ReactDOMTextComponent;","map":{"version":3,"names":["DOMChildrenOperations","require","DOMPropertyOperations","ReactComponentBrowserEnvironment","ReactMount","assign","escapeTextContentForBrowser","setTextContent","validateDOMNesting","ReactDOMTextComponent","props","prototype","construct","text","_currentElement","_stringText","_rootNodeID","_mountIndex","mountComponent","rootID","transaction","context","process","env","NODE_ENV","ancestorInfoContextKey","useCreateElement","ownerDocument","ownerDocumentContextKey","el","createElement","setAttributeForID","getID","escapedText","renderToStaticMarkup","createMarkupForID","receiveComponent","nextText","nextStringText","node","getNode","updateTextContent","unmountComponent","unmountIDFromEnvironment","module","exports"],"sources":["/Users/rlborgen/git/ionconfig/editor/node_modules/react-popout/node_modules/react/lib/ReactDOMTextComponent.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMChildrenOperations = require('./DOMChildrenOperations');\nvar DOMPropertyOperations = require('./DOMPropertyOperations');\nvar ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');\nvar ReactMount = require('./ReactMount');\n\nvar assign = require('./Object.assign');\nvar escapeTextContentForBrowser = require('./escapeTextContentForBrowser');\nvar setTextContent = require('./setTextContent');\nvar validateDOMNesting = require('./validateDOMNesting');\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactDOMTextComponent = function (props) {\n  // This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function (text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text;\n\n    // Properties\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    this._rootNodeID = rootID;\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID);\n      // Populate node cache\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function (nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n\n  unmountComponent: function () {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n\n});\n\nmodule.exports = ReactDOMTextComponent;"],"mappings":"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"},"metadata":{},"sourceType":"script"}