{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n'use strict';\n\nvar DOMProperty = require('./DOMProperty');\n\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\n\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\n\nvar ReactElement = require('./ReactElement');\n\nvar ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');\n\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\n\nvar ReactInstanceMap = require('./ReactInstanceMap');\n\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\n\nvar ReactPerf = require('./ReactPerf');\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\n\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\n\nvar containsNode = require('fbjs/lib/containsNode');\n\nvar instantiateReactComponent = require('./instantiateReactComponent');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar setInnerHTML = require('./setInnerHTML');\n\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\n\nvar validateDOMNesting = require('./validateDOMNesting');\n\nvar warning = require('fbjs/lib/warning');\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\n/** Mapping from reactRootID to React component instance. */\n\nvar instancesByReactRootID = {};\n/** Mapping from reactRootID to `container` nodes. */\n\nvar containersByReactRootID = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n} // Used to store breadth-first search state in findComponentRoot.\n\n\nvar findComponentRootReusableArray = [];\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\n\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n\n  return string1.length === string2.length ? -1 : minLen;\n}\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n * a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\n\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\n\n\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\n\n\nfunction getID(node) {\n  var id = internalGetID(node);\n\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n\n      if (cached !== node) {\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\n\n\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\n\n\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\n\n\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\n    return null;\n  }\n\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\n\n\nfunction isValid(node, id) {\n  if (node) {\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\n    var container = ReactMount.findReactContainerForID(id);\n\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\n\n\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\n\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\n\n\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\n\n\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\n  if (ReactDOMFeatureFlags.useCreateElement) {\n    context = assign({}, context);\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      context[ownerDocumentContextKey] = container;\n    } else {\n      context[ownerDocumentContextKey] = container.ownerDocument;\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (context === emptyObject) {\n      context = {};\n    }\n\n    var tag = container.nodeName.toLowerCase();\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\n  }\n\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\n\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\n}\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\n\n\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* forceHTML */\n  shouldReuseMarkup);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n/**\n * Unmounts a component and removes it from the DOM.\n *\n * @param {ReactComponent} instance React component instance.\n * @param {DOMElement} container DOM element to unmount from.\n * @final\n * @internal\n * @see {ReactMount.unmountComponentAtNode}\n */\n\n\nfunction unmountComponentFromNode(instance, container) {\n  ReactReconciler.unmountComponent(instance);\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  } // http://jsperf.com/emptying-a-node\n\n\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n/**\n * True if the supplied DOM node has a direct React-rendered child that is\n * not a React root element. Useful for warning in `render`,\n * `unmountComponentAtNode`, etc.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM element contains a direct child that was\n * rendered by React but is not a root element.\n * @internal\n */\n\n\nfunction hasNonRootReactChild(node) {\n  var reactRootID = getReactRootID(node);\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\n}\n/**\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\n * of React.\n */\n\n\nfunction findFirstReactDOMImpl(node) {\n  // This node might be from another React instance, so we make sure not to\n  // examine the node cache here\n  for (; node && node.parentNode !== node; node = node.parentNode) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      continue;\n    }\n\n    var nodeID = internalGetID(node);\n\n    if (!nodeID) {\n      continue;\n    }\n\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID); // If containersByReactRootID contains the container we find by crawling up\n    // the tree, we know that this instance of React rendered the node.\n    // nb. isValid's strategy (with containsNode) does not work because render\n    // trees may be nested and we don't want a false positive in that case.\n\n    var current = node;\n    var lastID;\n\n    do {\n      lastID = internalGetID(current);\n      current = current.parentNode;\n\n      if (current == null) {\n        // The passed-in node has been detached from the container it was\n        // originally rendered into.\n        return null;\n      }\n    } while (lastID !== reactRootID);\n\n    if (current === containersByReactRootID[reactRootID]) {\n      return node;\n    }\n  }\n\n  return null;\n}\n/**\n * Temporary (?) hack so that we can store all top-level pending updates on\n * composites instead of having to worry about different types of components\n * here.\n */\n\n\nvar TopLevelWrapper = function TopLevelWrapper() {};\n\nTopLevelWrapper.prototype.isReactComponent = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\n\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\n\n\nvar ReactMount = {\n  TopLevelWrapper: TopLevelWrapper,\n\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function scrollMonitor(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function _registerComponent(nextComponent, container) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n    var componentInstance = instantiateReactComponent(nextElement, null);\n\n    var reactRootID = ReactMount._registerComponent(componentInstance, container); // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\n\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\n\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\n            break;\n          }\n\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\n\n    if (callback) {\n      callback.call(component);\n    }\n\n    return component;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function render(nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function registerContainer(container) {\n    var reactRootID = getReactRootID(container);\n\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function unmountComponentAtNode(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n\n    if (!component) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container); // Check if the container itself is a React root node.\n\n      var containerID = internalGetID(container);\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\n      }\n\n      return false;\n    }\n\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n\n    return true;\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function findReactContainerForID(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n\n      if (rootElement && rootElement.parentNode !== container) {\n        process.env.NODE_ENV !== 'production' ? warning( // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\n        var containerChild = container.firstChild;\n\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function findReactNodeByID(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component rendered by this copy of React.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function getFirstReactDOM(node) {\n    return findFirstReactDOMImpl(node);\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function findComponentRoot(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw on the next line; give an early warning\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\n    }\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\n  },\n  _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n        var normalizedMarkup = markup;\n\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\n\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\n        }\n      }\n    }\n\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n\n      container.appendChild(markup);\n    } else {\n      setInnerHTML(container, markup);\n    }\n  },\n  ownerDocumentContextKey: ownerDocumentContextKey,\n\n  /**\n   * React ID utilities.\n   */\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  getNodeFromInstance: getNodeFromInstance,\n  isValid: isValid,\n  purgeID: purgeID\n};\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\nmodule.exports = ReactMount;","map":{"version":3,"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactDOMFeatureFlags","ReactElement","ReactEmptyComponentRegistry","ReactInstanceHandles","ReactInstanceMap","ReactMarkupChecksum","ReactPerf","ReactReconciler","ReactUpdateQueue","ReactUpdates","assign","emptyObject","containsNode","instantiateReactComponent","invariant","setInnerHTML","shouldUpdateReactComponent","validateDOMNesting","warning","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","DOCUMENT_FRAGMENT_NODE_TYPE","ownerDocumentContextKey","Math","random","toString","slice","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","firstDifferenceIndex","string1","string2","minLen","min","length","i","charAt","getReactRootElementInContainer","container","nodeType","documentElement","firstChild","getReactRootID","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","undefined","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","getNodeFromInstance","instance","get","_rootNodeID","isNullComponentID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","mountComponentIntoNode","componentInstance","rootID","transaction","shouldReuseMarkup","context","useCreateElement","ownerDocument","tag","nodeName","toLowerCase","ancestorInfoContextKey","updatedAncestorInfo","markup","mountComponent","_renderedComponent","_topLevelWrapper","_mountImageIntoNode","batchedMountComponentIntoNode","ReactReconcileTransaction","getPooled","perform","release","unmountComponentFromNode","unmountComponent","lastChild","removeChild","hasNonRootReactChild","reactRootID","getReactRootIDFromNodeID","findFirstReactDOMImpl","parentNode","nodeID","current","lastID","TopLevelWrapper","prototype","isReactComponent","displayName","render","props","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextElement","callback","enqueueElementInternal","enqueueCallbackInternal","_registerComponent","nextComponent","ensureScrollValueMonitoring","registerContainer","_renderNewRootComponent","getName","batchedUpdates","renderSubtreeIntoContainer","parentComponent","_reactInternalInstance","_renderSubtreeIntoContainer","isValidElement","tagName","toUpperCase","nextWrappedElement","prevWrappedElement","_currentElement","prevElement","publicInst","getPublicInstance","updatedCallback","call","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","containerHasNonRootReactChild","nextSibling","rootElementSibling","component","_processChildContext","_context","createReactRootID","containerID","isContainerReactRoot","containerChild","reactRoot","findComponentRoot","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","child","targetChild","childID","isAncestorIDOf","push","canReuseMarkup","checksum","CHECKSUM_ATTR_NAME","removeAttribute","rootMarkup","outerHTML","normalizedMarkup","normalizer","document","createElement","innerHTML","body","appendChild","contentDocument","write","diffIndex","difference","substring","measureMethods","module","exports"],"sources":["/Users/rlborgen/git/ionconfig/editor/node_modules/react-popout/node_modules/react/lib/ReactMount.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = require('./DOMProperty');\nvar ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');\nvar ReactElement = require('./ReactElement');\nvar ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\nvar ReactPerf = require('./ReactPerf');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar containsNode = require('fbjs/lib/containsNode');\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar invariant = require('fbjs/lib/invariant');\nvar setInnerHTML = require('./setInnerHTML');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar validateDOMNesting = require('./validateDOMNesting');\nvar warning = require('fbjs/lib/warning');\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n * a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\n  if (ReactDOMFeatureFlags.useCreateElement) {\n    context = assign({}, context);\n    if (container.nodeType === DOC_NODE_TYPE) {\n      context[ownerDocumentContextKey] = container;\n    } else {\n      context[ownerDocumentContextKey] = container.ownerDocument;\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (context === emptyObject) {\n      context = {};\n    }\n    var tag = container.nodeName.toLowerCase();\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\n  }\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* forceHTML */shouldReuseMarkup);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Unmounts a component and removes it from the DOM.\n *\n * @param {ReactComponent} instance React component instance.\n * @param {DOMElement} container DOM element to unmount from.\n * @final\n * @internal\n * @see {ReactMount.unmountComponentAtNode}\n */\nfunction unmountComponentFromNode(instance, container) {\n  ReactReconciler.unmountComponent(instance);\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  }\n\n  // http://jsperf.com/emptying-a-node\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n\n/**\n * True if the supplied DOM node has a direct React-rendered child that is\n * not a React root element. Useful for warning in `render`,\n * `unmountComponentAtNode`, etc.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM element contains a direct child that was\n * rendered by React but is not a root element.\n * @internal\n */\nfunction hasNonRootReactChild(node) {\n  var reactRootID = getReactRootID(node);\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\n}\n\n/**\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\n * of React.\n */\nfunction findFirstReactDOMImpl(node) {\n  // This node might be from another React instance, so we make sure not to\n  // examine the node cache here\n  for (; node && node.parentNode !== node; node = node.parentNode) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      continue;\n    }\n    var nodeID = internalGetID(node);\n    if (!nodeID) {\n      continue;\n    }\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n\n    // If containersByReactRootID contains the container we find by crawling up\n    // the tree, we know that this instance of React rendered the node.\n    // nb. isValid's strategy (with containsNode) does not work because render\n    // trees may be nested and we don't want a false positive in that case.\n    var current = node;\n    var lastID;\n    do {\n      lastID = internalGetID(current);\n      current = current.parentNode;\n      if (current == null) {\n        // The passed-in node has been detached from the container it was\n        // originally rendered into.\n        return null;\n      }\n    } while (lastID !== reactRootID);\n\n    if (current === containersByReactRootID[reactRootID]) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Temporary (?) hack so that we can store all top-level pending updates on\n * composites instead of having to worry about different types of components\n * here.\n */\nvar TopLevelWrapper = function () {};\nTopLevelWrapper.prototype.isReactComponent = {};\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n\n  TopLevelWrapper: TopLevelWrapper,\n\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\n    // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\n\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\n\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\n\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\n            break;\n          }\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n      // Check if the container itself is a React root node.\n      var containerID = internalGetID(container);\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\n      }\n\n      return false;\n    }\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (process.env.NODE_ENV !== 'production') {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        process.env.NODE_ENV !== 'production' ? warning(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\n        var containerChild = container.firstChild;\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component rendered by this copy of React.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    return findFirstReactDOMImpl(node);\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw on the next line; give an early warning\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\n    }\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\n  },\n\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n\n        var normalizedMarkup = markup;\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\n\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\n        }\n      }\n    }\n\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n      container.appendChild(markup);\n    } else {\n      setInnerHTML(container, markup);\n    }\n  },\n\n  ownerDocumentContextKey: ownerDocumentContextKey,\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  getNodeFromInstance: getNodeFromInstance,\n\n  isValid: isValid,\n\n  purgeID: purgeID\n};\n\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\n\nmodule.exports = ReactMount;"],"mappings":"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"},"metadata":{},"sourceType":"script"}